from __future__ import print_function
import numpy as np
from hdf5storage import loadmat, savemat
from scipy.optimize import minimize, minimize_scalar
from scipy.linalg import norm
from scipy.interpolate import Akima1DInterpolator, RectBivariateSpline
from matplotlib import pyplot as plt
from tqdm import tqdm
import sys

sys.path.append("../../SurfaceTrapSim/")

from world import World
from electrode import RRPESElectrode, Electrode

class STAQregion(World):
	"""
	HOA2 object-oriented simulator of 1 certain region
	Major Referrences: HOA2-manual.pdf
	junc_center is the axial coordinate in this certain region
	"""
	en_list = np.asarray(["GND","RF"]+["G"+str(i+1).zfill(2) for i in range(8)]+\
		["L"+str(i+1).zfill(2) for i in range(16)]+["Q"+str(i+1).zfill(2) for i in range(40)]+\
		["T"+str(i+1).zfill(2) for i in range(6)] +["Y"+str(i+1).zfill(2) for i in range(24)])
	ax_perm = [1,2,0]

	def __init__(self, v_rf, w_rf, ionA, fname='RS1096_12400_1.bin'):
		self.fname, suffix = fname.split('.')
		World.__init__(self, ionA, w_rf, 1e-3) # length unit: mm
		self.v_rf = v_rf
		if suffix=='bin':
			diffed = False
			self.__load_header()
			datae = self.__load_data()
			
			# permute axes
			self.n_samp = self.n_samp[STAQregion.ax_perm]
			self.roi    = self.roi[STAQregion.ax_perm]
			datae       = np.transpose(datae,[0]+[l+1 for l in STAQregion.ax_perm])
		
		elif suffix=='mat':
			diffed = True
			datae = self.__load_from_mat()
		self.__load_electrodes(datae, diffed)

		self.cutoff = 100 # those effectively further than cutoff (mm) are not under the control of multipoles
		self.w_dist = 1   # weight on distance
		self.w_asym = 1   # weight on asymmetry

	def zrange(self):
		reg = self.fname.split('_')[-1]
		return (-2.3085,2.3085) if reg=='1' else (0,0.560)

	def __load_header(self):
		"""
		Load the binary data from file self.fname. Refer to Table 4 in the HOA2 manual
		length unit: mm
		"""
		with open(self.fname+".bin", 'rb') as f:
			raw = f.read(160)
			self.Nelectrodes = np.frombuffer(raw[8:16], np.int64)[0]
			self.n_samp = np.frombuffer(raw[16:40], np.int64)
			# self.vsets = np.frombuffer(raw[40:48], np.int64)[0]
			# self.axisxy = np.frombuffer(raw[48:96]).reshape((2,-1))*1000
			strides = np.frombuffer(raw[96:120])*1e3 # length unit: mm
			origin = np.frombuffer(raw[120:144])*1e3
			self.roi = np.array([np.array([0,self.n_samp[i]-1])*strides[i] + origin[i] for i in range(3)])
			raw = f.read(8*self.Nelectrodes)
			# self.electrodemapping = np.frombuffer(raw, np.int64)

	def __load_data(self):
		with open(self.fname+".bin", 'rb') as f:
			raw = f.read(160+8*self.Nelectrodes)
			raw = f.read()
			return np.frombuffer(raw).reshape(self.Nelectrodes, *self.n_samp)

	def __load_from_mat(self):
		"""
		Load interpolant-differentiated grids generated by Matlab,
		otherwise directly read the binary file provided by Sandia.
		Loading from a bin2mat.py-generated mat file is UNSUPPORTED, since that's unnecessary
		"""
		print("Loading .mat file")
		Simulation = loadmat(self.fname + '.mat')
		Simulation = Simulation[Simulation.keys()[0]] # due to the save syntax of Matlab
		self.n_samp = np.array([Simulation[l].size for l in ["X","Y","Z"]])
		self.roi = np.array([Simulation[l].ravel()[[0,-1]] for l in ["X","Y","Z"]])

		try:
			self.Nelectrodes = Simulation['Nelectrodes']
		except:
			self.Nelectrodes = 96
		data_diffed = [None]*(self.Nelectrodes)
		data_diffed[0] = Simulation["EL_GD"]
		data_diffed[1] = Simulation["EL_RF"]
		for j in range(1, self.Nelectrodes-1):
			data_diffed[j+1] = Simulation["EL_DC%d"%j]
		return data_diffed

	def __load_electrodes(self, datae, diffed):
		self.lap_resid = np.empty((self.Nelectrodes,2),np.uint32)
		grid_vecs = tuple([np.linspace(self.roi[l,0],self.roi[l,1],self.n_samp[l]) for l in range(3)])
		for i, nm in enumerate(STAQregion.en_list):
			print('\b',nm,end='\t')
			if i == 0:
				print('Ignored')
				continue # neglect GND

			if not diffed:
				elec = RRPESElectrode(grid_vecs, datae[i])
				elec.finite_diff()
			else:
				data = datae[i]
				elec = RRPESElectrode(grid_vecs, data['pot'].reshape(self.n_samp), \
							grad_data=data['grad'], hess_data=data['hess'])
			self.lap_resid[i-1,:] = elec.check_laplace()
			elec.interpolate()
			self.add_electrode(Electrode(elec), nm, 'rf' if i==1 else 'dc', 0)
		assert len(self.rf_electrode_list)==1
		self.rf_electrode_list[0][1].volt = self.v_rf

	def vdc_ctrl_by_multipole_arr(self, position, ctrl_multipoles=['C','Ex','Ey','Ez','U1','U2','U3','U4','U5'],r0=1):
		effect_dist = np.asarray([e.compute_d_effective(position) for nm,e in self.dc_electrode_list])
		# We want to control the electrodes in pair, so we compare the pair-average effective distance with the position of interest
		# In order to make sure each pair is choosed or not as a whole
		effect_dist_mean = effect_dist.reshape((-1,2)).mean(axis=1)
		
		# those effectively further than self.cutoff(mm) are not involved in controlling the multipoles at the position of interest
		elec_list = np.arange(len(self.dc_electrode_list))[np.repeat(effect_dist_mean < self.cutoff, 2)]
		print("@(%g,%g,%g)um"%tuple(position*1e3),STAQregion.en_list[elec_list+2],"are involved in controlling the multipoles")
		
		cost_dist = np.diag(effect_dist)
		cost_asym = np.identity(len(self.dc_electrode_list))
		for j in range(len(self.dc_electrode_list)-1):
			if j%2==0:
				cost_asym[j,j+1]=-1
				cost_asym[j+1,j]=-1
		cost_Q = self.w_dist*cost_dist + self.w_asym*cost_asym

		# push in to the subspace of the involved voltages
		cost_Q = cost_Q[elec_list][:,elec_list]

		return self.multipole_control_vdc_arr(position, ctrl_multipoles, elec_list, cost_Q, r0), elec_list

	def compute_rf_null(self, z, xy0=(0,0.07), onyz=False, bounds=None):
		if bounds is None:
			self.check_bound()
			if self.bounds is None:
				print("Cannot carry out RF null searching without bounds")
				return
			else:
				bounds = self.bounds
		if onyz: # x=0 required
			yi = np.linspace(self.roi[1,0], self.roi[1,1], self.n_samp[1])
			e2i = np.asarray([sum(self.compute_rf_field(np.array([xy0[0],y,z]))**2) for y in yi])
			fo = Akima1DInterpolator(yi, e2i)
			ym = minimize_scalar(fo, bounds=tuple(bounds[1]), method="Bounded")
			if ym.success:
				return np.array([xy0[0],ym.x,z])
			else:
				print("@ z=%.3fmm Optimization Failed:"%z, ym.message, '. Returning initial value')
				ymy = xy0[1]
				yi = np.linspace(yi[0],yi[-1],30)
				plt.plot(yi, [fo(yy) for yy in yi], label="%.3f"%z)
				plt.xlabel("y/mm")
				plt.ylabel(r"$E_{RF}^2/\mathrm{(V^2mm^{-2})}$")
				plt.title("RF null @x = 0")
			# if ym.success:
			# 	plt.plot([ymy],[ym.fun],'x')
			# else:
				# plt.legend(title="z/mm")
				plt.show()
		else:
			xi,yi = [np.linspace(self.roi[l,0], self.roi[l,1], self.n_samp[l]) for l in range(2)]
			e2i = np.empty(self.n_samp[:2])
			for ix, x in enumerate(xi):
				e2i[ix,:] = [sum(self.compute_rf_field(np.array([x,y,z]))**2) for y in yi]
			spl = RectBivariateSpline(xi,yi,e2i)
			xym = minimize(lambda xy: spl(xy[0],xy[1])[0,0], xy0, bounds=self.bounds[:2])
			if xym.success:
				return np.array([xym.x[0],xym.x[1],z])
			else:
				print("Optimization Failure", xym.message)

	def compute_nodal_line(self, onyz=True):
		cache_found = False
		reg = self.fname.split('_')[-1]
		try:
			# print('nodal_%s.npy'%reg)
			nodh = np.load('nodal_%s.npy'%reg)
			if nodh.shape[1] == (2 if onyz else 3):
				cache_found = True
		except:
			pass
		if not cache_found:
			zi = np.linspace(self.roi[2,0], self.roi[2,1], self.n_samp[2])[2:-2]
			nodh = []
			for iz, z in tqdm(enumerate(zi),desc="Computing nodal line"):
				null = self.compute_rf_null(z,(0,0.07),onyz)
				if null is not None:
					nodh.append(null)
			nodh = np.asarray(nodh)
			if onyz:
				nodh = nodh[:,1:]
			np.save('nodal_%s.npy'%reg, nodh)

		self.nodal = {"y": Akima1DInterpolator(nodh[:,-1], nodh[:,-2])}
		if not onyz:
			self.nodal["x"] = Akima1DInterpolator(nodh[:,-1], nodh[:,0])

	def check_n_elec_involved(self, cutoff, zrange=None):
		"""
		Roughly check if there's enough electrodes involved in multipole controlling when setting self.cutoff=cutoff
		"""
		if zrange is None:
			zrange = self.zrange()
			zrange = np.arange(zrange[0], zrange[1], 0.01)
		ne_involv = np.empty((zrange.size),'i')
		for iz,z in enumerate(zrange):
			position = np.array([0, self.nodal['y'](z), z])
			effect_dist = np.asarray([e.compute_d_effective(position) for nm,e in self.dc_electrode_list])
			effect_dist_mean = effect_dist.reshape((-1,2)).mean(axis=1)
			ne_involv[iz] = 2*sum(effect_dist_mean < cutoff)
		return zrange, ne_involv


	def dump_bin(self):
		for ie in range(self.Nelectrodes):
			with open(self.fname+'_pots/%d.csv'%ie,'w') as f:
				print("x/mm\ty/mm\tz/mm\tpot_DC/V",file=f)
				for ix in np.arange(self.nx):
					for iy in np.arange(self.ny):
						for iz in np.arange(self.nz):
							print(self.xs[ix],self.ys[iy],self.zs[iz],self.data[ie,ix,iy,iz],sep=',',file=f)

def volt_profile(voltages, multipoles):
	fig, axes = plt.subplots(3,3)
	axes = axes.ravel()
	for i, mult in enumerate(multipoles):
		volt = voltages[:,i]
		volt = np.log10(abs(volt[volt!=0]))
		axes[i].hist(volt)
		axes[i].set_title(mult)
		axes[i].set_xlabel("lg(|V|)")
	plt.show()

if __name__ == "__main__":
	Electrode.multipole_convention = 'Littich'
	steve = STAQregion(250, 45e6, 171, "RS1096_12400_5um_1.mat")

	# output laplace residue
	savemat("lap_res_interp_diff1um",{"lap_res":steve.lap_resid})
	plt.hist(steve.lap_resid[1:,1])
	plt.xlabel("Numbers of Laplacian bad points in the bulk")
	plt.ylabel("Number of DC electrodes")
	plt.show()

	# # Comparison with the MATLAB code: A simple case
	# center = np.array([0,0.07,0])
	# ctrl_mult = ['Ex','Ey','Ez','U1','U2','U3','U4','U5']
	# mult_arr = steve.construct_multipole_arr(center)
	# # calculate the voltage_arr at the central position
	# # with the simplest cost function: norm of the voltage vector
	# volt_arr = steve.multipole_control_vdc_arr(center, ctrl_mult)
	# # np.savez("center_cost-id.npz", mult_arr=mult_arr, volt_arr=volt_arr)
	# savemat("../pyMATComparison/center_cost-id_convention-%s.mat"%(Electrode.multipole_convention),{u"mult_arr":mult_arr,u"volt_arr":volt_arr})
	# print("The demo at central position is calculated. Please compare the results with the MATLAB results.")
	
	# steve.compute_nodal_line()
	# print("Nodal line loaded")
	# steve.cutoff = 70
	# zrange = np.arange(-2.309, 2.310, 0.001)
	# ctrl_mult = ['C','Ex','Ey','Ez','U1','U2','U3','U4','U5']
	# volt_arrs = np.empty((zrange.size, len(steve.dc_electrode_list), len(ctrl_mult)),'d')
	# positions = np.empty((zrange.size, 3))
	# for iz,z in enumerate(zrange):
	# 	pos = np.array([0,steve.nodal["y"](z),z])
	# 	positions[iz,:] = pos
	# 	volt_arrs[iz,:,:] = steve.vdc_ctrl_by_multipole_arr(pos, ctrl_mult)[0]
	# np.savez_compressed("sweep_through-cut70.npz",volt_arrs=volt_arrs, pos=positions)

